

module ALUDecoder (input logic ALUOp,
						 input logic [4:0] Funct,
						 output logic [1:0] ALUControl, FlagW);

	always @(*)
    if (ALUOp) begin                 // which DP Instr?
      case(Funct[4:1]) 
  	    4'b0100: ALUControl = 4'b0000; // ADD
  	    4'b0010: ALUControl = 4'b0010; // SUB
        4'b0000: ALUControl = 4'b0100; // AND
  	    4'b1100: ALUControl = 4'b0101; // ORR
        4'b0001: ALUControl = 4'b0110; // EOR  
  	    default: ALUControl = 4'bx;  // unimplemented
      endcase
    // update flags if S bit is set 
	// (C & V only updated for arith instructions)
      FlagW[1] = Funct[0]; // FlagW[1] = S-bit
	// FlagW[0] = S-bit & (ADD | SUB)
      FlagW[0] = Funct[0] & 
        (ALUControl == 4'b0000 | ALUControl == 4'b0010); 
    end else begin
      ALUControl = 4'b0000; // add for non-DP instructions
      FlagW      = 2'b00; // don't update Flags
    end
endmodule 